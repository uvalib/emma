# General utility methods.
#
module TestHelper::Utility
  include TestHelper::Common

  # The "/test/fixtures/users.yml" entry associated with the argument.
  #
  # @param [String, Symbol, *] arg
  #
  # @return [Symbol, nil]
  #
  def user_entry: (untyped arg) -> (Symbol | nil)

  # Return a User instance from the given identification.
  #
  # @param [String, Symbol, User, *] user
  #
  # @return [User]
  # @return [nil]                     If *user* could not be converted.
  #
  def find_user: (untyped user) -> (User | nil)

  # Return multiple User instances.
  #
  # @param [Array] list               All users if empty.
  # @param [Hash]  matching           Limiting conditions if present.
  #
  # @return [Array<User>]
  #
  def find_users: (*(String|Symbol|User|nil) list, **untyped matching) -> Array[User|nil]

  # The number of fixture records for the indicated model and constraints which
  # are associated with an organization.
  #
  # @param [Symbol, String, Class, ApplicationRecord] model
  # @param [Org, User, Integer, nil]                  org
  # @param [Hash]                                     constraints
  #
  # @return [Integer]
  #
  def fixture_count_for_org: (Symbol|String|Class|ApplicationRecord model, Org|User|Integer|nil org, **untyped constraints) -> Integer

  # The number of fixture records for the indicated model and constraints which
  # are associated with the given user.
  #
  # @param [Symbol, String, Class, ApplicationRecord] model
  # @param [User, Integer, nil]                       user
  # @param [Hash]                                     constraints
  #
  # @return [Integer]
  #
  def fixture_count_for_user: (Symbol|String|Class|ApplicationRecord model, User|Integer|nil user, **untyped constraints) ?{ (Symbol,ApplicationRecord) -> bool } -> Integer

  # The number of fixture records for the indicated model and constraints.
  #
  # @param [Symbol, String, Class, ApplicationRecord] model
  # @param [Hash]                                     constraints
  #
  # @return [Integer]
  #
  def fixture_count: (Symbol|String|Class|ApplicationRecord model, **untyped constraints) ?{ (Symbol,ApplicationRecord) -> bool } -> Integer

  # A table of fixture value Hashes for the indicated model type, optionally
  # matching the given constraints, which are associated with an organization.
  #
  # @param [Symbol, String, Class, ApplicationRecord] model
  # @param [Org, User, Integer, nil]                  org
  # @param [Hash]                                     constraints
  #
  # @return [Hash{Symbol=>Hash{Symbol=>*}}]
  #
  def fixture_values_for_org: (Symbol|String|Class|ApplicationRecord model, Org|User|Integer|nil org, **untyped constraints) -> Hash[Symbol, symHash]

  # A table of fixture value Hashes for the indicated model type, optionally
  # matching the given constraints, which are associated with the given user.
  #
  # @param [Symbol, String, Class, ApplicationRecord] model
  # @param [User, Integer, nil]                       user
  # @param [Hash]                                     constraints
  #
  # @return [Hash{Symbol=>Hash{Symbol=>*}}]
  #
  def fixture_values_for_user: (Symbol|String|Class|ApplicationRecord model, User|Integer|nil user, **untyped constraints) ?{ (Symbol,ApplicationRecord) -> bool } -> Hash[Symbol, symHash]

  # A table of fixture value Hashes for the indicated model type, optionally
  # matching the given constraints.
  #
  # @param [Symbol, String, Class, ApplicationRecord] model
  # @param [Hash]                                     constraints
  #
  # @return [Hash{Symbol=>Hash{Symbol=>*}}]
  #
  def fixture_values: (Symbol|String|Class|ApplicationRecord model, **untyped constraints) ?{ (Symbol,ApplicationRecord) -> bool } -> Hash[Symbol, symHash]

  # Fixture set for the indicated model type.
  #
  # @param [Symbol, String, Class, ApplicationRecord] model
  #
  # @return [ActiveRecord::FixtureSet, nil]
  #
  def fixtures_of: (Symbol|String|Class|ApplicationRecord model) -> (ActiveRecord::FixtureSet | nil)

  # Extract the EMMA index entry identifier from the item.
  #
  # @param [SearchResult, nil] item
  # @param [String, nil]       repo
  # @param [String, nil]       rid
  # @param [String, nil]       format
  # @param [String, nil]       ver
  #
  # @return [String]
  #
  def record_id
    : ( SearchResult item, ?repo: String|nil, ?rid: String|nil, ?format: String|nil, ?ver: String|nil) -> String
    | (?nil          item,  repo: String,      rid: String,      format: String,     ?ver: String|nil) -> String

  # Note in the output that a test was skipped because it was not applicable.
  #
  # @param [String, nil] note         Additional annotation.
  #
  # @return [true]
  #
  def not_applicable: (?(String|nil) note) -> true

  # Note in the output that a test was skipped because the given format was not
  # applicable (or if none was given whether any of the currently configured
  # formats in #TEST_FORMATS are applicable).
  #
  # @param [Array, Symbol, nil] fmt
  # @param [String, nil]        note  Additional annotation.
  # @param [Array, Symbol, nil] only  Applicable format(s) or :all; default:
  #                                     #TEST_FORMATS.
  #
  # @return [true]                    If the test should proceed.
  # @return [false]                   If the test should be skipped.
  #
  def allowed_format
    : ((Symbol|symArray|nil) fmt, ?(String|nil) note, only: Symbol|symArray|nil) -> bool
    | (                           ?(String|nil) note, only: Symbol|symArray|nil) -> bool
end
