# General utility methods.
#
module TestHelper::Utility
  include TestHelper::Common

  include TestHelper::Debugging

  # For controller tests to covering the differences between authenticated and
  # non-authenticated sessions.
  #
  # @type [Array<Symbol>]
  #
  CORE_TEST_USERS: symArray

  # For controller tests to covering varying behaviors depending on the role
  # of the user session.
  #
  # @type [Array<Symbol>]
  #
  ALL_TEST_USERS: symArray

  # Run the test code provided via the block.
  #
  # When debugging, this frames the console output generated by the test.
  #
  # @param [String, Symbol, nil] test_name
  # @param [Symbol, nil]         format     @see #allowed_format.
  # @param [Array, Symbol, nil]  only       @see #allowed_format.
  # @param [Integer, nil]        wait       @see #using_wait_time.
  # @param [Hash]                opt        @see #SHOW_TEST_OPT
  # @param [Proc]                blk        Required block.
  #
  # @return [void]
  #
  # @yield The test code to be run
  # @yieldreturn [void]
  #
  def run_test: (String|Symbol|nil test_name, ?format: Symbol|nil, ?only: symArray|Symbol|nil, ?wait: Integer|nil, **untyped opt) { () -> void } -> void

  # Local options for #run_test.
  #
  # @type [Array<Symbol>]
  #
  RUN_TEST_OPT: symArray

  # Make sure that "Sign in as" is visible on the sign-in page by ensuring that
  # the interface is in "debug mode".
  #
  # This also initializes `request.referrer` to a known good page so that
  # `redirect :back` will always work without need for a fallback location
  # (which may or may not be appropriate).
  #
  # @return [void]
  #
  def prime_tests: () -> void

  # @private
  # @type [Boolean, nil]
  attr_accessor tests_primed: bool?

  # The "/test/fixtures/users.yml" entry associated with the argument.
  #
  # @param [any, nil] arg             String, Symbol
  #
  # @return [Symbol, nil]
  #
  def user_entry: (untyped arg) -> (Symbol | nil)

  # Return a User instance from the given identification.
  #
  # @param [any, nil] user            String, Symbol, User
  #
  # @return [User]
  # @return [nil]                     If *user* could not be converted.
  #
  def find_user: (untyped user) -> (User | nil)

  # Return multiple User instances.
  #
  # @param [Array] list               All users if empty.
  # @param [Hash]  matching           Limiting conditions if present.
  #
  # @return [Array<User>]
  #
  def find_users: (*(String|Symbol|User|nil) list, **untyped matching) -> Array[User|nil]

  # Extract the User ID indicated by *item*.
  #
  # @param [any, nil] item          Symbol, String, Integer, Hash, Model, User
  #
  # @return [Integer, nil]
  #
  def uid: (untyped item) -> (Integer | nil)

  # Extract the Organization ID indicated by *item*.
  #
  # @param [any, nil] item          Symbol, String, Integer, Hash, Model, Org
  #
  # @return [Integer, nil]
  #
  def oid: (untyped item) -> (Integer | nil)

  # The number of fixture records for the indicated model and constraints which
  # are associated with an organization.
  #
  # @param [Symbol, String, Class, ApplicationRecord] model
  # @param [Org, User, Integer, nil]                  org
  # @param [Hash]                                     constraints
  #
  # @return [Integer]
  #
  def fixture_count_for_org: (Symbol|String|Class|ApplicationRecord model, Org|User|Integer|nil org, **untyped constraints) -> Integer

  # The number of fixture records for the indicated model and constraints which
  # are associated with the given user.
  #
  # @param [Symbol, String, Class, ApplicationRecord] model
  # @param [User, Integer, nil]                       user
  # @param [Hash]                                     constraints
  #
  # @return [Integer]
  #
  def fixture_count_for_user: (Symbol|String|Class|ApplicationRecord model, User|Integer|nil user, **untyped constraints) -> Integer

  # The number of fixture records for the indicated model and constraints.
  #
  # @param [Symbol, String, Class, ApplicationRecord] model
  # @param [Hash]                                     constraints
  #
  # @return [Integer]
  #
  def fixture_count: (Symbol|String|Class|ApplicationRecord model, **untyped constraints) ?{ (Symbol,ApplicationRecord) -> bool } -> Integer

  # A table of fixture value Hashes for the indicated model type, optionally
  # matching the given constraints, which are associated with an organization.
  #
  # @param [Symbol, String, Class, ApplicationRecord] model
  # @param [Org, User, Integer, nil]                  org
  # @param [Hash]                                     constraints
  #
  # @return [Hash{Symbol=>Hash}]
  #
  # @note Currently unused
  #
  def fixture_values_for_org: (Symbol|String|Class|ApplicationRecord model, Org|User|Integer|nil org, **untyped constraints) -> Hash[Symbol, symHash]

  # A table of fixture value Hashes for the indicated model type, optionally
  # matching the given constraints, which are associated with the given user.
  #
  # @param [Symbol, String, Class, ApplicationRecord] model
  # @param [User, Integer, nil]                       user
  # @param [Hash]                                     constraints
  #
  # @return [Hash{Symbol=>Hash}]
  #
  # @note Currently unused
  #
  def fixture_values_for_user: (Symbol|String|Class|ApplicationRecord model, User|Integer|nil user, **untyped constraints) -> Hash[Symbol, symHash]

  # A table of fixture value Hashes for the indicated model type, optionally
  # matching the given constraints.
  #
  # @param [Symbol, String, Class, ApplicationRecord] model
  # @param [Hash]                                     constraints
  #
  # @return [Hash{Symbol=>Hash}]
  #
  def fixture_values: (Symbol|String|Class|ApplicationRecord model, **untyped constraints) ?{ (Symbol,ApplicationRecord) -> bool } -> Hash[Symbol, symHash]

  # Fixture set for the indicated model type.
  #
  # @param [Symbol, String, Class, ApplicationRecord] model
  #
  # @return [ActiveRecord::FixtureSet, nil]
  #
  def fixtures_of: (Symbol|String|Class|ApplicationRecord model) -> (ActiveRecord::FixtureSet | nil)

  # Generate a string of random hex digits.
  #
  # @return [String]
  #
  def hex_rand: () -> String

  # Extract the EMMA index entry identifier from the item.
  #
  # @param [SearchResult, nil] item
  # @param [String, nil]       repo
  # @param [String, nil]       rid
  # @param [String, nil]       format
  # @param [String, nil]       ver
  #
  # @return [String]
  #
  def record_id
    : ( SearchResult item, ?repo: String|nil, ?rid: String|nil, ?format: String|nil, ?ver: String|nil) -> String
    | (?nil          item,  repo: String,      rid: String,      format: String,     ?ver: String|nil) -> String

  # Note in the output that a test was skipped.
  #
  # @param [Array,nil] msg            Message part(s).
  # @param [Hash]      opt            Passed to #show_item.
  #
  # @return [void]
  #
  def show_skipped: (*untyped msg, **untyped opt) -> void

  # Note in the output that a test was skipped because it was not applicable.
  #
  # @param [String, nil] note         Additional annotation.
  # @param [Hash]        opt          Passed to #show_skipped.
  #
  # @return [true]
  #
  def not_applicable: (?(String|nil) note, **untyped opt) -> true

  # Note in the output that a test was skipped because the given format was not
  # applicable (or if none was given whether any of the currently configured
  # formats in #TEST_FORMATS are applicable).
  #
  # @param [Array, Symbol, nil] fmt
  # @param [String, nil]        note  Additional annotation.
  # @param [Array, Symbol, nil] only  Applicable format(s) or :all; default:
  #                                     #TEST_FORMATS.
  #
  # @return [true]                    If the test should proceed.
  # @return [false]                   If the test should be skipped.
  #
  def allowed_format
    : ((Symbol|symArray|nil) fmt, ?(String|nil) note, only: Symbol|symArray|nil) -> bool
    | (                           ?(String|nil) note, only: Symbol|symArray|nil) -> bool

  # Option keys for sending requests which are not URL parameters.
  #
  # @type [Array<Symbol>]
  #
  REQUEST_OPT: symArray

  # Option keys supporting test methods which are not URL parameters.
  #
  # @type [Array<Symbol>]
  #
  TEST_OPT: symArray

  # Option keys which are not URL parameters.
  #
  # @type [Array<Symbol>]
  #
  NON_URL_PARAMETER_KEYS: symArray

  # For controllers whose "/index" action is actually a redirect to one or more
  # possible list actions.
  #
  # @param [Symbol, String, Proc, nil] dst
  # @param [any, nil]                  user   String, Symbol, User
  # @param [Hash]                      opt
  #
  # @return [String]                  The redirection path.
  # @return [nil]                     If *opt* includes search terms.
  #
  def index_redirect: (?dst: Symbol|String|Proc|nil, ?user: untyped, **untyped opt) ?{ () -> (Symbol|String|Proc|nil) } -> (String | nil)
end
