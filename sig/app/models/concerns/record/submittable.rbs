# TODO: workflow logic
#
# NOTE: This is basically UploadWorkflow::External but without any of the
#   Workflow module-specific stuff.
#
# NOTE: A big problem here may be the built-in assumption that there's only one
#   type of record to deal with...
#
module Record::Submittable
  extend ActiveSupport::Concern

  include Record

  include Record::EmmaIdentification

  include Record::Exceptions

  include Record::Properties

  module RecordMethods
    include Record::Submittable

    def emma_item?: (untyped item) -> bool

    def incomplete?: (untyped item) -> bool

    def new_record: (?(symHash|Model)? data) -> Model

    def add_title_prefix: (Model record, prefix: String) -> void
  end

  module DatabaseMethods
    include Record::Submittable

    include Record::Submittable::RecordMethods

    def db_insert: (symHash|Model data) -> ApplicationRecord

    def db_update: (symHash|Model|String item, ?(symHash|nil) data) -> ApplicationRecord

    def db_delete: (symHash|Model|String item) -> (untyped | nil)
  end

  module IndexIngestMethods
    include Record::Submittable

    include ExecReport::Constants

    # :nocov:
    #include Record::Submittable::SubmissionMethods

    def ingest_api: () -> IngestService

    # As a convenience for testing, sending to the Federated Search Ingest API  # NOTE: from UploadWorkflow::External
    # can be short-circuited here.  The value should be *false* normally.
    #
    # @type [Boolean]
    #
    DISABLE_UPLOAD_INDEX_UPDATE: bool

    def add_to_index: (*Entry items, ?atomic: bool) -> [Array[Entry], Array[Record::Exceptions::FlashPart], Array[Entry]]

    def update_in_index: (*Entry items, ?atomic: bool) -> [Array[Entry], Array[Record::Exceptions::FlashPart], Array[Entry]]

    def remove_from_index: (*(Model|String) items, ?atomic: bool) -> [Array[Entry], Array[Record::Exceptions::FlashPart]]

    def skip_index_ingest: (Symbol meth, *(Entry|Model|String) items) -> ([Array[Entry], []] | [Array[Model|String], []])

    # Interpret error message(s) generated by Federated Ingest to determine     # NOTE: from UploadWorkflow::External
    # which item(s) failed.
    #
    # @param [Ingest::Message::Response, Hash{String,Integer=>String}] result
    # @param [Array<Model,String>]                                     items
    #
    # @return [Array<(Array,Array,Array)>]   Succeeded records, failed item messages,
    #                                   and records to roll back.
    #
    # @see ExecReport#error_table
    #
    # == Implementation Notes
    # It's not clear whether there would ever be situations where there was a
    # mix of errors by index, errors by submission ID, and/or general errors,
    # but this method was written to be able to cope with the possibility.
    #
    # -
    # noinspection RubyMismatchedReturnType
    # +
    def process_ingest_errors: (Ingest::Message::Response|Hash[(String|Integer),String] result, *(Model|String) items) -> [Array[Entry], Array[Record::Exceptions::FlashPart], Array[Entry]]

    def normalize_index_items: (*(Entry|String|Array[Entry|String]) items, ?meth: Symbol?, ?max: Integer) -> Array[Entry|String]
  end

  module MemberRepositoryMethods
    include Record::Submittable

    include Record::Submittable::IndexIngestMethods

    def aws_api: () -> AwsS3Service

    # Failure messages for member repository requests. # TODO: I18n             # NOTE: from UploadWorkflow::External
    #
    # @type [Hash{Symbol=>String}]
    #
    REPO_FAILURE: Hash[Symbol,String]

    def repository_create: (*Model items, **untyped opt) -> [Array[Model], Array[Record::Exceptions::FlashPart]]

    def repository_modify: (*Model items, **untyped opt) -> [Array[Model], Array[Record::Exceptions::FlashPart]]

    def repository_remove: (*Model items, **untyped opt) -> [Array[Model], Array[Record::Exceptions::FlashPart]]

    def repository_dequeue: (*Model items, **untyped opt) -> [Array[Model], Array[Record::Exceptions::FlashPart]]

    # Interpret error message(s) generated by AWS S3.                           # NOTE: from UploadWorkflow::External
    #
    # @param [AwsS3::Message::Response, Hash{String,Integer=>String}] result
    # @param [Array<String,Model>]                                    items
    #
    # @return [Array<(Array,Array)>]         Succeeded items and failed item messages.
    #
    # @see ExecReport#error_table
    #
    def process_aws_errors: (AwsS3::Message::Response|Hash[(String|Integer),String] result, *(String|Model) items) -> [Array[String|Model], Array[Record::Exceptions::FlashPart]]

    def repository_removals: (symHash|String|Model|Array[String|Model]|nil items, **untyped opt) ->  [Array[String|Model], Array[Record::Exceptions::FlashPart]]

    def repository_dequeues: (symHash|Array[String|Model]|nil items, **untyped opt) -> [Array[String|Model], Array[Record::Exceptions::FlashPart]]

    def repository_requests: (symHash|Array[String|Model]|nil items, ?empty_key: bool) -> [Array[String|Model], Array[Record::Exceptions::FlashPart]]
  end

  module BatchMethods
    include Record::Submittable

    include Record::Submittable::RecordMethods

    include Record::Submittable::MemberRepositoryMethods

    # :nocov:
    #include Record::Submittable::SubmissionMethods

    def batch_entry_remove: (Array[symHash|String|Integer|Model]|nil ids, ?index: bool, ?atomic: bool, ?force: bool?, **untyped opt) -> [Array[String|Model], Array[Record::Exceptions::FlashPart]]

    def batch_entry_operation: (Symbol op, Array[symHash|String|Integer|Model] items, ?size: (Integer|bool)?, **untyped opt) -> [Array[String|Model], Array[Record::Exceptions::FlashPart]]

    def throttle: (Integer counter, ?frequency: Integer, ?pause: bool|Float) -> Integer
  end

  module SubmissionMethods
    include Record::Submittable

    include Record::Submittable::RecordMethods

    include Record::Submittable::DatabaseMethods

    include Record::Submittable::IndexIngestMethods

    include Record::Submittable::MemberRepositoryMethods

    include Record::Submittable::BatchMethods

    def entry_create: (?index: bool?, ?atomic: bool?, **untyped data) -> [(Entry | nil), Array[Record::Exceptions::FlashPart]]

    def entry_edit: (?index: bool?, ?atomic: bool?, **untyped data) -> [(Entry | nil), Array[Record::Exceptions::FlashPart]]

    def entry_remove: (*(Entry|String|Array[Entry|String]) items, ?index: bool?, ?atomic: bool?, ?force: bool?, **untyped opt) -> [Array[String|Model], Array[Record::Exceptions::FlashPart]]

    private

    def item_label: (untyped item) -> String
  end

  private

  THIS_MODULE: Module

  include Record::Submittable::SubmissionMethods

  extend Record::Submittable::SubmissionMethods
end
