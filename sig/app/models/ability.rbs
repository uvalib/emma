# Definitions for role-based authorization through CanCan.
#
# A method call like `can :read, :upload` basically assumes a few things:
# - There's an UploadController with typical CRUD endpoints.
# - The :read argument implies permission for the :index and :show endpoints.
# - The controller manipulates instances of the Upload resource.
#
class Ability
  include Emma::Common

  include CanCan::Ability

  # The standard CRUD actions controller presumed by CanCan.
  #
  # @type [Array<Symbol>]
  #
  ACTIONS: symArray

  # Existing pre-defined action aliases.
  #
  # This does not include the :manage action (which is an implicit alias for
  # "all actions").
  #
  # @type [Hash{Symbol=>Array<Symbol>}]
  #
  # @see CanCan::Ability::Actions#default_alias_actions
  # @see CanCan::Rule#matches_action?
  #
  PREDEFINED_ALIAS: Hash[Symbol,symArray]

  # Locally-defined aliases.
  #
  # Keys with empty values essentially document abilities that are used within
  # the code and are not actually used as CanCan aliases.
  #
  # @type [Hash{Symbol=>Array<Symbol>}]
  #
  LOCAL_ACTION_ALIAS: Hash[Symbol,symArray]

  # Both existing and new action aliases.
  #
  # @type [Hash{Symbol=>Array<Symbol>}]
  #
  ACTION_ALIAS: Hash[Symbol,symArray]

  # Models which are managed by CanCan (that is the model names implied by all
  # of the controllers which have "authorize_resource").
  #
  # For consistency, each of these should have an entry in
  # "en.unauthorized.manage" (config/locales/cancan.en.yml).
  #
  # @type [Array<Symbol>]
  #
  MODEL_NAMES: symArray

  # Create a new instance.
  #
  # @param [User, nil] user
  #
  # === Usage Notes
  # Define abilities for the passed-in user here. For example:
  #
  #   user ||= User.new # guest user (not logged in)
  #   if user.admin?
  #     can :manage, :all
  #   else
  #     can :read, :all
  #   end
  #
  # The first argument to `can` is the action you are giving the user
  # permission to do.
  # If you pass :manage it will apply to every action. Other common actions
  # here are :read, :create, :update and :destroy.
  #
  # The second argument is the resource the user can perform the action on.
  # If you pass :all it will apply to every resource. Otherwise pass a Ruby
  # class of the resource.
  #
  # The third argument is an optional hash of conditions to further filter the
  # objects.
  # For example, here the user can only update published articles.
  #
  #   can :update, Article, :published => true
  #
  # See the wiki for details:
  # @see https://github.com/CanCanCommunity/cancancan/wiki/Defining-Abilities
  #
  def initialize: ((User|nil) user) -> void

  # Assign the ability to perform as a system developer.
  #
  # @param [User] user
  #
  # @return [void]
  #
  # @see IdentityHelper#developer?
  #
  # === Usage Notes
  # This is functionally equivalent to :administrator in terms of the Ability
  # class. Wherever the distinction needs to be made, the user's role must be
  # explicitly checked.
  #
  def act_as_developer: (User user) -> void

  # Assign the ability to perform as a system administrator.
  #
  # @param [User] user
  #
  # @return [void]
  #
  def act_as_administrator: (User user) -> void

  # Assign the ability to perform as a Disability Service Officer.
  #
  # @param [User] user
  #
  # @return [void]
  #
  def act_as_dso: (User user) -> void

  # Assign the ability to perform as an assistant to a DSO (without permission
  # to download).
  #
  # @param [User] user
  #
  # @return [void]
  #
  # === Usage Notes
  # Currently, "DSO Delegate" is basically a synonym for "Librarian".
  #
  def act_as_dso_delegate: (User user) -> void

  # Assign the ability to perform as a librarian.
  #
  # @param [User] user
  #
  # @return [void]
  #
  # === Usage Notes
  # The current idea is that library staff might perform all of the entry
  # creation and maintenance functions that a DSO would (minus the ability to
  # download remediated content files).
  #
  def act_as_librarian: (User user) -> void

  # Assign the ability to perform as a member organization staff (without permission
  # to download).
  #
  # @param [User] user
  #
  # @return [void]
  #
  def act_as_staff: (User user) -> void

  # Assign the ability to perform as a signed-in user.
  #
  # @param [User] user
  #
  # @return [void]
  #
  def act_as_authenticated: (User user) -> void

  # Assign the ability to perform as a guest user.
  #
  # @param [User] user
  #
  # @return [void]
  #
  # === Usage Notes
  # Currently, "Guest" is basically a synonym for "Anonymous".
  #
  def act_as_guest: (User user) -> void

  # Assign the ability to perform as an anonymous (unauthenticated) user.
  #
  # @return [void]
  #
  def act_as_anonymous: (*untyped _ignored) ?{ () -> untyped } -> void

  # Allow full control over EMMA submissions which are associated with the
  # user's ID.
  #
  # @param [User] user
  #
  # @return [void]
  #
  def can_manage_own_account: (User user) -> void

  # Allow full control over EMMA submissions which are associated with the
  # user's group ID.
  #
  # @param [User] user
  #
  # @return [void]
  #
  # @note This is not yet supported by any data model.
  #
  def can_manage_group_account: (User user) -> void

  # Define a set of capabilities on EMMA submissions which allows full control
  # over instances which meet the given constraints.
  #
  # @param [Class] model
  # @param [Hash]  with_constraints
  #
  # @return [void]
  #
  def can_manage_account: (?Class model, **untyped with_constraints) -> void

  # Allow full control over EMMA submissions which are associated with the
  # user's ID.
  #
  # @param [User] user
  #
  # @return [void]
  #
  def can_manage_own_entries: (User user) -> void

  # Allow full control over EMMA submissions which are associated with the
  # user's group ID.
  #
  # @param [User] user
  #
  # @return [void]
  #
  # @note This is not yet supported by any data model.
  #
  def can_manage_group_entries: (User user) -> void

  # Define a set of capabilities on EMMA bulk operations which allows full
  # control over instances which meet the given constraints.
  #
  # @param [Hash] with_constraints
  #
  # @return [void]
  #
  def can_manage_bulk_operations: (**untyped with_constraints) -> void

  # Define a set of capabilities on EMMA submissions which allows full control
  # over instances which meet the given constraints.
  #
  # @param [Class] model
  # @param [Hash]  with_constraints
  #
  # @return [void]
  #
  def can_manage_entries: (?Class model, **untyped with_constraints) -> void

  # Allow full control over model instances which are associated with the
  # user's ID.
  #
  # @param [Class] model
  # @param [User]  user
  #
  # @return [void]
  #
  # @note Currently unused
  #
  def can_manage_own: (Class model, User user) -> void

  # Allow full control over model instances which are associated with the
  # user's group ID.
  #
  # @param [Class] model
  # @param [User]  user
  #
  # @return [void]
  #
  # @note Currently unused
  # @note This is not yet supported by any data model.
  #
  def can_manage_group: (Class model, User user) -> void

  # Define a set of capabilities on a given model type which allows full
  # control over instances which meet the given constraints.
  #
  # @param [Class] model
  # @param [Hash]  with_constraints
  #
  # @return [void]
  #
  def can_manage_records: (Class model, **untyped with_constraints) -> void

  # Define a set of capabilities on a given model type which allows basic
  # control over instances which meet the given constraints.
  #
  # @param [Class] model
  # @param [Hash]  with_constraints
  #
  # @return [void]
  #
  def can_manage: (Class model, **untyped with_constraints) -> void

  # Check if the user has permission to perform a given action on an object.
  #
  # Always *false* if *action* is *nil*.
  #
  # @param [Symbol, String, nil] action
  # @param [Object, Class, *]    subject
  # @param [*]                   extra_args
  #
  def can?
    : (nil           action, Object|Class|untyped subject, *untyped extra_args) -> false
    | (Symbol|String action, Object|Class|untyped subject, *untyped extra_args) -> bool

  # Returns the opposite of the #can? method.
  #
  # Always *true* if *action* is *nil*.
  #
  # @param [Symbol, String, nil] action
  # @param [Object, Class, *]    subject
  # @param [*]                   extra_args
  #
  def cannot?
    : (nil           action, Object|Class|untyped subject, *untyped extra_args) -> true
    | (Symbol|String action, Object|Class|untyped subject, *untyped extra_args) -> bool

  # Add a rule allowing an action.
  #
  # @param [Symbol,String,Array,nil] action
  # @param [*]                       subject
  # @param [Array]                   conditions
  #
  # @return [void]
  #
  def can: (?(Symbol|String|Array[Symbol|String]|nil) action, ?untyped subject, *untyped conditions) -> void

  # Add a rule forbidding an action.
  #
  # @param [Symbol,String,Array,nil] action
  # @param [*]                       subject
  # @param [Array]                   conditions
  #
  # @return [void]
  #
  def cannot: (?(Symbol|String|Array[Symbol|String]|nil) action, ?untyped subject, *untyped conditions) -> void

  # The constraints that apply to the Ability instance for the given
  # action/subject or *nil*.
  #
  # If *nil* is returned, `can?(action,subject)` applies to any applicable
  # record; otherwise, although #can? may return true, the current user is
  # only able to operate on records that match the constraint criteria.
  #
  # @param [Symbol, String, nil] action
  # @param [*]                   subject
  #
  # @return [ActiveRecord::Relation, Hash, Proc, nil]
  #
  def constrained_by: (Symbol|String|nil action, untyped subject) -> (ActiveRecord::Relation | symHash | Proc | nil)

  private

  # Normalize values for use with #can? and #cannot?.
  #
  # @param [Symbol,String,Array,nil] action
  # @param [*]                       subject
  # @param [Array]                   conditions
  #
  # @return [Array<(*,*,*)>]
  #
  def prep_conditions: (?(Symbol|String|Array[Symbol|String]|nil) action, ?untyped subject, anyArray conditions) -> void

  public

  def all_actions_inspect: () -> String

  def self.all_actions: () -> Hash[Symbol,anyArray]

  def all_actions: () -> Hash[Symbol,anyArray]

  def self.all_actions_sort: () -> Hash[Symbol,anyArray]

  def all_actions_sort: () -> Hash[Symbol,anyArray]

  def self.all_actions_keys: () -> symArray

  def all_actions_keys: () -> symArray

  def self.all_actions_for: (ApplicationRecord|Class model) -> symArray

  def all_actions_for: (ApplicationRecord|Class model) -> symArray

  def self.all_actions_add: (?(Symbol|String|Array[Symbol|String]|nil) action, untyped subject) -> void

  def all_actions_add: (?(Symbol|String|Array[Symbol|String]|nil) action, untyped subject) -> void

  def self.all_actions_remove: (?(Symbol|String|Array[Symbol|String]|nil) action, untyped subject) -> void

  def all_actions_remove: (?(Symbol|String|Array[Symbol|String]|nil) action, untyped subject) -> void

  # Models which are managed by CanCan
  #
  # @return [Array<Class>]
  #
  # @see #MODEL_NAMES
  #
  def self.models: () -> Array[Class]
end
