# @note This class may go away...
class CallbackJob < ApplicationJob
  include Emma::Debug

  extend Emma::Debug

  # @private
  CLASS: Class

  # @return [ApplicationRecord<Record::Steppable>]
  attr_reader receiver: ApplicationRecord

  # @return [Symbol]
  attr_reader meth: Symbol

  # @return [CallbackJob, nil]
  attr_accessor callback: CallbackJob | nil

  # initialize
  #
  # @param [ApplicationRecord] src
  # @param [Symbol]            meth
  # @param [CallbackJob, nil]  callback
  #
  def initialize: (ApplicationRecord src, Symbol meth, ?callback: CallbackJob|nil) -> void

  # Enqueue or run the callback as a job.
  #
  # @param [Boolean] async            Run synchronously if provided as *false*.
  # @param [Hash]    opt
  #
  # @return [Boolean]                 *false* if the job could not be processed
  #
  def cb_schedule: (?async: bool, **untyped opt) -> untyped

  # Run the callback as a synchronous job.
  #
  # @param [Hash] opt
  #
  # @return [Boolean]                 Always *true* # TODO: ???
  #
  def cb_perform_now: (**untyped opt) -> untyped

  # Queue a job to run the callback asynchronously.
  #
  # @param [Hash] opt
  #
  # @return [Boolean]                 *true* if queued; *false* if not.
  #
  def cb_perform_later: (**untyped opt) -> untyped

  def to_h: () -> { cb_receiver: ApplicationRecord, cb_method: Symbol, callback: CallbackJob? }

  alias to_hash to_h

  def self.cb_values: (untyped source, *untyped _ignored) -> ([ApplicationRecord, Symbol, CallbackJob?] | nil)

  class Serializer < ActiveJob::Serializers::ObjectSerializer
    def serialize: (untyped item) -> anyHash

    def deserialize: (anyHash hash) -> CallbackJob

    private

    def klass: () -> Class
  end
end
