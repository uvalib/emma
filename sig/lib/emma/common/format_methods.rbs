module Emma::Common::FormatMethods
  extend ::Emma::Common::FormatMethods

  # @type [Array<Symbol>]
  INFLECT_SINGULAR: symArray

  # @type [Array<Symbol>]
  INFLECT_PLURAL: symArray

  # Pluralize or singularize *text*.  If neither *inflection* nor *count* is
  # specified then a copy of the original string is returned.
  #
  # @param [ActiveSupport::SafeBuffer, String] text
  # @param [Integer, nil]                      count
  # @param [Symbol, nil]                       inflect
  #
  # @return [ActiveSupport::SafeBuffer, String]
  #
  # @see #INFLECT_SINGULAR
  # @see #INFLECT_PLURAL
  #
  def inflection
    : (ActiveSupport::SafeBuffer text, ?(Integer|nil) count, ?(Symbol|nil) inflect) -> ActiveSupport::SafeBuffer
    | (String text,                    ?(Integer|nil) count, ?(Symbol|nil) inflect) -> String

  # Render text that will not break on word boundaries.
  #
  # @param [String, nil] text
  # @param [Boolean]     force        If *true* then the translation will
  #                                     happen even if text.html_safe?.
  #
  # @return [ActiveSupport::SafeBuffer]
  #
  def non_breaking: (String? text, ?force: bool) -> ActiveSupport::SafeBuffer

  # Render a camel-case or snake-case string as in "title case" words separated
  # by non-breakable spaces.
  #
  # If *text* is already HTML-ready it is returned directly.
  #
  # @param [String, Symbol, nil]  text
  # @param [Integer, nil]         count       To #inflection if present.
  # @param [Boolean]              breakable   If *false* replace spaces with
  #                                             '&nbsp;' so that the result is
  #                                             not word-breakable.
  #
  # @return [ActiveSupport::SafeBuffer]
  #
  def labelize: ((String|Symbol|nil) text, ?count: Integer|nil, ?breakable: bool, **untyped _ignored) -> ActiveSupport::SafeBuffer

  # @type [Array<String>]
  QUOTE_MARKS: strArray

  # @type [Array<ActiveSupport::SafeBuffer>]
  HTML_QUOTES: Array[ActiveSupport::SafeBuffer]

  # Add surrounding quotation marks to a term.
  #
  # If the term is already quoted, those quotation marks are preserved.
  #
  # @param [*]      term
  # @param [String] quote
  # @param [String] separator
  #
  # @return [ActiveSupport::SafeBuffer, String]
  #
  # -
  # === Variations
  # +
  #
  # @overload quote(terms, quote: '"', separator: ', ')
  #   @param [Array<ActiveSupport::SafeBuffer>] terms
  #   @param [String]                           quote
  #   @param [String]                           separator
  #   @return [ActiveSupport::SafeBuffer]
  #
  # @overload quote(term, quote: '"', separator: ', ')
  #   @param [ActiveSupport::SafeBuffer] term
  #   @param [String]                    quote
  #   @param [String]                    separator
  #   @return [ActiveSupport::SafeBuffer]
  #
  # @overload quote(terms, quote: '"', separator: ', ')
  #   @param [Array]  terms
  #   @param [String] quote
  #   @param [String] separator
  #   @return [String]
  #
  # @overload quote(term, quote: '"', separator: ', ')
  #   @param [*]      term
  #   @param [String] quote
  #   @param [String] separator
  #   @return [String]
  #
  def quote
    : (ActiveSupport::SafeBuffer|Array[ActiveSupport::SafeBuffer] terms, ?quote: String, ?separator: String) -> ActiveSupport::SafeBuffer
    | (untyped                                                    terms, ?quote: String, ?separator: String) -> String

  # Remove pairs of surrounding quotation marks from a term.
  #
  # @param [*]      term
  # @param [String] separator
  #
  # @return [ActiveSupport::SafeBuffer, String]
  #
  # -
  # === Variations
  # +
  #
  # @overload strip_quotes(terms, separator: ', ')
  #   @param [Array<ActiveSupport::SafeBuffer>] terms
  #   @param [String]                           separator
  #   @return [ActiveSupport::SafeBuffer]
  #
  # @overload strip_quotes(term,separator: ', ')
  #   @param [ActiveSupport::SafeBuffer] term
  #   @param [String]                    separator
  #   @return [ActiveSupport::SafeBuffer]
  #
  # @overload strip_quotes(terms, separator: ', ')
  #   @param [Array]  terms
  #   @param [String] separator
  #   @return [String]
  #
  # @overload strip_quotes(term, separator: ', ')
  #   @param [*]      term
  #   @param [String] separator
  #   @return [String]
  #
  def strip_quotes
    : (ActiveSupport::SafeBuffer|Array[ActiveSupport::SafeBuffer] terms, ?separator: String) -> ActiveSupport::SafeBuffer
    | (untyped                                                    terms, ?separator: String) -> String

  # Match a named reference like "%{name}" for a #sprintf argument.
  #
  # @type [Regexp]
  #
  SPRINTF_NAMED_REFERENCE: Regexp

  # Match a formatted named reference like "%<name>s" for a #sprintf argument.
  #
  # @type [Regexp]
  #
  SPRINTF_FMT_NAMED_REFERENCE: Regexp

  # @private
  # @type [Array<Regexp>]
  SPRINTF_NAMED_REF_PATTERNS: Array[Regexp]

  # Extract the named references in a format string.
  #
  # @param [String, *]             text   String with #sprintf formatting.
  # @param [Array<Regexp>, Regexp] match  Patterns to match
  #
  # @return [Array<Symbol>]
  #
  # @see Kernel#sprintf
  #
  def named_references: (untyped text, ?(Array[Regexp]|Regexp) match) -> symArray

  # Match a named reference along with "%<name>s" the format portion.
  #
  # $1 = [String, nil] name
  # $2 = [String, nil] flags
  # $3 = [String, nil] width
  # $4 = [String, nil] precision
  # $5 = [String]      format
  #
  # @type [Regexp]
  #
  SPRINTF_FORMAT: Regexp

  # Extract the named references in a format string and pair them with their
  # respective sprintf formats.  Each "%{name}" reference is paired with "%s";
  # each "%<name>" reference is paired with the format which follows it.
  #
  # @param [String, *]   text         String with #sprintf formatting.
  # @param [String, nil] default_fmt  Format value for "%{name}" matches.
  #
  # @return [Hash{Symbol=>String}]
  #
  def named_references_and_formats: (untyped text, ?default_fmt: String|nil) -> Hash[Symbol,String]

  # Attempt to apply interpolations to all strings in *item*.
  #
  # @param [Hash, Array, String, *] item
  # @param [Hash]                   opt
  #
  # @return [*]
  #
  def deep_interpolate_named_references: [T] (T item, **untyped opt) -> T

  # If possible, make a copy of *text* with #sprintf named references replaced
  # by the matching values extracted from *src* or *opt*.  Otherwise return
  # *text* unchanged.
  #
  # If the name is capitalized or all uppercase (e.g. "%{Name}" or "%{NAME}")
  # then the interpolated value will follow the same case.
  #
  # @param [String, *]           text
  # @param [Array<Hash,Model,*>] src
  # @param [Hash]                opt
  #
  # @return [String]                  A modified copy of *text*.
  # @return [nil]                     If no interpolations could be made.
  #
  # === Usage Notes
  # If *text* contains a mix of named references and unnamed specifiers, the
  # assumption is that it will be processed in two passes -- first (by this
  # method) with a hash of values matching the named references generating an
  # intermediate string, then (by the caller) a second pass on that result to
  # supply values for the unnamed specifiers.
  #
  def interpolate_named_references
    : (ActiveSupport::SafeBuffer text, *untyped src, **untyped opt) -> ActiveSupport::SafeBuffer
    | (untyped                   text, *untyped src, **untyped opt) -> String

  # If possible, make a copy of *text* with #sprintf named references replaced
  # by the matching values extracted from *src* or *opt*.
  #
  # @param [String, *]           text
  # @param [Array<Hash,Model,*>] src
  # @param [Hash]                opt
  #
  # @return [String]                  A modified copy of *text*.
  # @return [nil]                     If no interpolations could be made.
  #
  # @see #interpolate_named_references
  #
  def interpolate_named_references!
    : (ActiveSupport::SafeBuffer text, *untyped src, **untyped opt) -> (ActiveSupport::SafeBuffer | nil)
    | (untyped                   text, *untyped src, **untyped opt) -> (String | nil)
end
