# app/services/concerns/api_service/common.rb
#
# frozen_string_literal: true
# warn_indent:           true

__loading_begin(__FILE__)

require 'net/https'
require 'faraday'

# ApiService::Common
#
module ApiService::Common

  # Include the shared data structure which holds the definition of the API
  # requests and parameters.
  #
  # @param [Module] base
  #
  def self.included(base)
    base.send(:include, ApiService::Definition)
    base.send(:extend,  ApiService::Definition)
  end

  include Emma::Common
  include Emma::Debug

  # ===========================================================================
  # :section:
  # ===========================================================================

  public

  BASE_URL = 'MISSING' # To be overridden.

  # Control whether information requests are ever cached. # TODO: ???
  #
  # @type [Boolean]
  #
  CACHING = false

  # Control whether parameter validation errors cause a RuntimeError.
  #
  # @type [Boolean]
  #
  RAISE_ON_INVALID_PARAMS = Rails.env.test?

  # Maximum length of redirection chain.
  #
  # @type [Integer]
  #
  MAX_REDIRECTS = 2

  # Options consumed by #api (and not passed on as URL query options).
  #
  # @type [Array<Symbol>]
  #
  SERVICE_OPTIONS = %i[no_raise no_exception no_redirect].freeze

  # Original request parameters which should not be passed on to the API.
  #
  # @type [Array<Symbol>]
  #
  IGNORED_PARAMETERS = (ParamsHelper::IGNORED_PARAMETERS + %i[offset]).freeze

  # HTTP methods used by the API.
  #
  # @type [Array<Symbol>]
  #
  # == Usage Notes
  # Compare with AllowsType#values.
  #
  HTTP_METHODS =
    %w(GET PUT POST DELETE)
      .map { |w| [w.to_sym, w.downcase.to_sym] }.flatten.deep_freeze

  # ===========================================================================
  # :section:
  # ===========================================================================

  public

  # The HTTP verb for the last #api access.
  #
  # @return [Symbol, nil]
  #
  attr_reader :verb

  # The URL path for the last #api access.
  #
  # @return [String, nil]
  #
  attr_reader :action

  # The URL parameters for the last #api access.
  #
  # @return [Hash, nil]
  #
  attr_reader :params

  # The API endpoint response generated by the last #api access.
  #
  # @return [Faraday::Response, nil]
  #
  attr_reader :response

  # Last API request type.
  #
  # @return [String]
  #
  def request_type
    @verb.to_s.upcase
  end

  # Most recently invoked HTTP request type.
  #
  # @return [String]
  #
  def latest_endpoint
    params = url_query(@params).presence
    [@action, params].compact.join('?')
  end

  # API key (if applicable).
  #
  # @return [String]
  # @return [nil]
  #
  def api_key
  end

  # ===========================================================================
  # :section: Exceptions
  # ===========================================================================

  public

  # The exception raised by the last #api access.
  #
  # @return [Exception, nil]
  #
  attr_reader :exception

  # Indicate whether the latest API request generated an exception.
  #
  def error?
    @exception.present?
  end

  # The message associated with the latest API exception.
  #
  # @return [String]
  # @return [nil]                     If there is no exception.
  #
  def error_message
    @exception&.message
  end

  # Cause an exception to be ignored to avoid generation of a flash message.
  #
  # @return [void]
  #
  # @see SessionConcern#session_update
  #
  def discard_exception
    @exception = nil
  end

  # ===========================================================================
  # :section: Authentication
  # ===========================================================================

  public

  # The user that invoked #api.
  #
  # @return [User, nil]
  #
  attr_reader :user

  # Extract the user name to be used for API parameters.
  #
  # @param [User, String] user
  #
  # @return [String]
  #
  def name_of(user)
    user.to_s
  end

  # ===========================================================================
  # :section: Authentication
  # ===========================================================================

  protected

  # Set the user for the current session.
  #
  # @param [User] u
  #
  # @return [void]
  #
  def set_user(u)
    raise "argument must be a User not a #{u.class}" if u && !u.is_a?(User)
    @user = u
  end

  # The current OAuth2 access bearer token.
  #
  # @return [String]
  # @return [nil]                     If there is no @user.
  #
  def access_token
    @user&.access_token
  end

  # The current OAuth2 refresher token.
  #
  # @return [String]
  # @return [nil]                     If there is no @user.
  #
  def refresh_token
    @user&.refresh_token
  end

  # ===========================================================================
  # :section:
  # ===========================================================================

  public

  # Get data from the API and update @response.
  #
  # @param [Symbol, String]           verb  One of :get, :post, :put, :delete
  # @param [Array<String,ScalarType>] args  Path components of the API request.
  # @param [Hash]                     opt   API request parameters.
  #
  # args[0]   [String]  Path component.
  # ...
  # args[-2]  [String]  Path component.
  # args[-1]  [Hash]    URL parameters except for:
  #
  # @option args.last [Boolean] :no_raise       If *true*, set @exception but
  #                                             do not raise it.
  #
  # @option args.last [Boolean] :no_exception   If *true*, neither set
  #                                             @exception nor raise it.
  #
  # @return [Faraday::Response]
  #
  # noinspection RubyScope
  def api(verb, *args, **opt)
    error = @verb = @action = @response = @exception = nil

    # Set local options from parameters or service options.
    opt, @params = partition_options(opt, *SERVICE_OPTIONS)
    no_exception = opt[:no_exception] || options[:no_exception]
    no_raise     = opt[:no_raise]     || options[:no_raise] || no_exception
    method       = opt[:method]       || calling_method

    # Build API call parameters (minus local options).
    @params.reject! { |k, _| IGNORED_PARAMETERS.include?(k) }
    decode_parameters!(@params)
    @params[:api_key] = api_key if api_key

    # Form the API path from the remaining arguments.
    @action = args.join('/').strip.prepend('/').squeeze('/')

    # Determine whether the HTTP method indicates a write rather than a read
    # and prepare the HTTP headers accordingly then send the API request.
    @verb   = verb.to_s.downcase.to_sym
    update  = %i[put post patch].include?(@verb)
    params  = update ? @params.to_json : @params
    headers = ({ 'Content-Type' => 'application/json' } if update)
    __debug_line(leader: '>>>') do
      %w(api) << @action.inspect <<
        { params: params, headers: headers }.transform_values { |v|
          v.inspect if v.present?
        }.compact
    end
    @response = transmit(@verb, @action, params, headers, **opt)

  rescue Api::Error => error
    log_exception(method: method, error: error)

  rescue => error
    log_exception(method: method, error: error)
    error = ApiService::ResponseError.new(error)

  ensure
    __debug_line(leader: '<<<') do
      # noinspection RubyNilAnalysis
      resp   = error.respond_to?(:response) && error.response || @response
      status = resp.respond_to?(:status) && resp.status || resp&.dig(:status)
      data   = resp.respond_to?(:body) && resp.body || resp&.dig(:body)
      %w(api) << @action.inspect <<
        { status: status, data: data }.transform_values do |v|
          v.inspect.truncate(256)
        end
    end
    @response  = nil   if error
    @exception = error unless no_exception
    raise @exception   if @exception unless no_raise
    return @response
  end

  # ===========================================================================
  # :section:
  # ===========================================================================

  protected

  # Get a connection for making cached requests.
  #
  # @return [Faraday::Connection]
  #
  # @see ApiCachingMiddleWare#initialize
  #
  def connection
    @connection ||= make_connection
  end

  # Get a connection.
  #
  # @param [String, nil] url          Default: `#base_url`
  #
  # @return [Faraday::Connection]
  #
  def make_connection(url = nil)
    conn_opts = {
      url:     (url || base_url),
      request: options.slice(:timeout, :open_timeout),
    }
    conn_opts[:request][:params_encoder] ||= Faraday::FlatParamsEncoder

    retry_opt = {
      max:                 options[:retry_after_limit],
      interval:            0.05,
      interval_randomness: 0.5,
      backoff_factor:      2,
    }

    Faraday.new(conn_opts) do |bld|
      bld.use           :instrumentation
      bld.use           :api_caching_middleware if CACHING
      bld.authorization :Bearer, access_token   if access_token.present?
      bld.request       :retry,  retry_opt
      bld.response      :logger, Log.logger
      bld.response      :raise_error
      bld.adapter       options[:adapter] || Faraday.default_adapter
    end
  end

  # Send an API request.
  #
  # @param [Symbol]            verb
  # @param [String]            action
  # @param [Hash, String, nil] params
  # @param [Hash, nil]         headers
  # @param [Hash]              opt
  #
  # @raise [ApiService::EmptyResultError]
  # @raise [ApiService::HtmlResultError]
  # @raise [ApiService::RedirectionError]
  # @raise [ApiService::ResponseError]
  #
  # @return [Faraday::Response]
  # @return [nil]
  #
  def transmit(verb, action, params, headers, **opt)
    response = connection.send(verb, action, params, headers)
    raise ApiService::EmptyResultError.new(response) if response.nil?
    redirection = no_redirect = nil
    case response.status
      when 200..299
        result = response.body
        raise ApiService::EmptyResultError.new(response) if result.blank?
        raise ApiService::HtmlResultError.new(response)  if result =~ /^\s*</
      when 301, 303, 308
        redirection = opt[:redirection].to_i
        no_redirect = (redirection >= MAX_REDIRECTS)
      when 302, 307
        redirection = opt[:redirection].to_i
        no_redirect = (redirection >= MAX_REDIRECTS)
        no_redirect ||=
          opt.key?(:no_redirect) ? opt[:no_redirect] : options[:no_redirect]
      else
        raise ApiService::ResponseError.new(response)
    end
    if redirection
      action = response.headers['Location']
      raise ApiService::RedirectionError.new(response) if action.blank?
      unless no_redirect
        opt[:redirection] = (redirection += 1)
        __debug_line(leader: '!!!') do
          %w(api) << "REDIRECT #{redirection} TO #{action.inspect}"
        end
        response = transmit(:get, action, params, headers, **opt)
      end
    end
    response
  end

  # ===========================================================================
  # :section:
  # ===========================================================================

  protected

  # Extract API parameters from *opt*.
  #
  # @param [Symbol]  method
  # @param [Boolean] check_req        Check for missing required keys.
  # @param [Boolean] check_opt        Check for extra optional keys.
  # @param [Hash]    opt
  #
  # @return [Hash]                    Just the API parameters from *opt*.
  # @return [nil]                     If *method* is not an API method.
  #
  def get_parameters(method, check_req: true, check_opt: false, **opt)
    properties     = api_methods(method)
    return invalid_params(method, 'unregistered API method') if properties.nil?
    multi          = Array.wrap(properties[:multi])
    required_keys  = required_parameters(method)
    optional_keys  = optional_parameters(method)
    key_alias      = properties[:alias] || {}
    specified_keys = required_keys + optional_keys + key_alias.keys
    specified_keys += SERVICE_OPTIONS

    # Validate the keys provided.
    errors = []
    if check_req && (missing_keys = required_keys - opt.keys).present?
      error = +'missing API ' << 'parameter'.pluralize(missing_keys.size)
      errors.push(error << ' ' << missing_keys.join(', '))
    end
    if check_opt && (extra_keys = opt.keys - specified_keys).present?
      error = +'invalid API ' << 'parameter'.pluralize(extra_keys.size)
      errors.push(error << ' ' << extra_keys.join(', '))
    end
    invalid_params(method, *errors) if errors.present?

    # Return with the options needed for the API request.
    # @type [Symbol] k
    # @type [*]      v
    opt.slice(*specified_keys).map { |k, v|
      k = key_alias[k] || k
      v = quote(v, separator: ' ') if v.is_a?(Array) && !multi.include?(k)
      k = encode_parameter(k)
      [k, v]
    }.to_h
  end

  # Preserve a key that would be mistaken for an ignored system parameter.
  #
  # @param [Symbol] key
  #
  # @return [Symbol]
  #
  def encode_parameter(key)
    IGNORED_PARAMETERS.include?(key) ? "_#{key}".to_sym : key
  end

  # Preserve keys that would be mistaken for an ignored system parameter.
  #
  # @param [Hash] opt
  #
  # @return [Hash]                    A modified copy of *opt*.
  #
  def encode_parameters(opt = nil)
    encode_parameters!(opt&.dup || {})
  end

  # Preserve keys that would be mistaken for an ignored system parameter.
  #
  # @param [Hash] opt
  #
  # @return [Hash]                    The original *opt* now modified.
  #
  def encode_parameters!(opt)
    opt.transform_keys! { |k| encode_parameter(k) }
  end

  # Reverse the transform of #encode_parameter.
  #
  # @param [Symbol] key
  #
  # @return [Symbol]
  #
  def decode_parameter(key)
    key.to_s.sub(/^_/, '').to_sym
  end

  # Restore preserved keys.
  #
  # @param [Hash] opt
  #
  # @return [Hash]                    A modified copy of *opt*.
  #
  def decode_parameters(opt = nil)
    decode_parameters!(opt&.dup || {})
  end

  # Restore preserved keys.
  #
  # @param [Hash] opt
  #
  # @return [Hash]                    The original *opt* now modified.
  #
  def decode_parameters!(opt)
    opt.transform_keys! { |k| decode_parameter(k) }
  end

  # ===========================================================================
  # :section:
  # ===========================================================================

  private

  # Report on errors in parameters supplied to an API method.
  #
  # @param [String, Symbol] method
  # @param [Array<String>]  errors
  # @param [Boolean]        raise_exception
  #
  # @raise [RuntimeError]             Iff *raise_exception*.
  #
  # @return [nil]
  #
  def invalid_params(method, *errors, raise_exception: RAISE_ON_INVALID_PARAMS)
    return if errors.blank?
    if raise_exception
      raise RuntimeError, ("#{method}: " + errors.join("\nAND "))
    else
      errors.each { |problem| Log.warn("#{method}: #{problem}") }
    end
    nil
  end

  # ===========================================================================
  # :section: Exceptions
  # ===========================================================================

  protected

  # log_exception
  #
  # @param [Exception]         error
  # @param [Symbol]            action
  # @param [Faraday::Response] response
  # @param [Symbol, String]    method
  #
  # @return [void]
  #
  def log_exception(error:, action: @action, response: @response, method: nil)
    method ||= 'request'
    message = error.message.inspect
    __debug_line(leader: '!!!') do
      %w(api) << action.inspect << message << error.class
    end
    level  = error.is_a?(Api::Error) ? Log::WARN : Log::ERROR
    status = %i[http_status status].find { |m| error.respond_to?(m) }
    status = status ? error.send(status).inspect : '???'
    body   = response&.body
    Log.log(level) do
      log = ["API #{method}: #{message}"]
      log << "status #{status}"
      log << "body #{body}" if body.present?
      log.join('; ')
    end
  end

end

__loading_end(__FILE__)
