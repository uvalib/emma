# app/helpers/layout_helper/page_controls.rb
#
# frozen_string_literal: true
# warn_indent:           true

__loading_begin(__FILE__)

# Control bar which holds action controls appropriate for the current page and
# the current user.
#
module LayoutHelper::PageControls

  include LayoutHelper::Common

  include ConfigurationHelper
  include IdentityHelper
  include LinkHelper
  include ParamsHelper

  # Non-functional hints for RubyMine type checking.
  unless ONLY_FOR_DOCUMENTATION
    # :nocov:
    include Emma::Common::ObjectMethods
    # :nocov:
  end

  # ===========================================================================
  # :section:
  # ===========================================================================

  public

  # Indicate whether it is appropriate to show page controls.
  #
  # @param [Hash, nil] p              Default: `#request_parameters`.
  #
  def show_page_controls?(p = nil)
    p ||= request_parameters
    !p[:controller].to_s.include?('devise')
  end

  # Render the appropriate partial to insert page controls if they are defined
  # for the current controller/action.
  #
  # @param [String] css               CSS class/selector for outer container.
  # @param [Hash]   opt
  #
  # @option opt [String, Symbol] :controller    Alias for :ctrlr.
  # @option opt [String, Symbol] :ctrlr         Default: `params[:controller]`.
  # @option opt [String, Symbol] :action        Default: `params[:action]`.
  # @option opt [String]         :label_id
  #
  # @return [ActiveSupport::SafeBuffer] An HTML element.
  # @return [nil]                       If no page_controls configured.
  #
  def render_page_controls(css: '.page-controls', **opt)
    opt     = request_parameters.merge(opt)
    ctl     = opt[:ctrlr]  = (opt.delete(:controller) || opt[:ctrlr])&.to_sym
    act     = opt[:action] = opt[:action]&.to_sym
    entries = page_control_actions(ctrlr: ctl, action: act).presence or return
    anchor  = "#{act}-page-controls"
    lbl_id  = opt.delete(:label_id) || css_randomize(anchor)

    skip_nav_prepend(ctl => anchor)

    label =
      html_div(class: 'label', id: lbl_id) do
        page_controls_label(**opt)
      end

    controls =
      html_div(class: 'controls', id: anchor, 'aria-labelledby': lbl_id) do
        page_controls(*entries, **opt.slice(:ctrlr, :action, :id))
      end

    html_div(class: css_classes(css, "count-#{entries.size}")) do
      label << controls
    end
  end

  # Generate a list of controller/action pairs that the current user is able to
  # perform.
  #
  # If an action is given by an array, the first element is interpreted as a
  # controller.  If not the controller for *model* is assumed.
  #
  # @param [Symbol] ctrlr
  # @param [Symbol] action
  #
  # @return [Array<Hash>>]            Ctrlr/action entries with optional label.
  # @return [nil]                     No authorized actions were found.
  #
  # @see "en.emma.page.*.page_controls.actions"
  # @see "en.emma.page.*.action.page_controls.actions"
  #
  def page_control_actions(ctrlr:, action:)
    cfg_opt = { ctrlr: ctrlr, action: action, mode: false }
    entries = config_lookup('page_controls.actions', **cfg_opt)
    return if entries.blank?
    model   = model_class(ctrlr)
    user    = (@user || current_user)
    subject = (user if model == User)
    log     = (->(m) { Log.debug("#{__method__}: #{m}") } if Log.debug?)
    entries.map { |ent|
      next if ent.blank?
      ent = ent.first if ent.is_a?(Array) && !ent.many?
      case ent
        when Hash
          ent = ent.values.first.merge(action: ent.keys.first) unless ent.many?
        when Array
          ent = { ctrlr: ent[0], action: ent[1], id: ent[2] }
        else
          ent = { ctrlr: ctrlr,  action: ent }
      end
      ent.compact_blank!

      act = ent[:action]
      next log&.("no action for entry #{ent.inspect}") unless act.present?

      ctl = ent[:ctrlr] = ent.delete(:controller) || ent[:ctrlr] || ctrlr
      sub = subject || model_class(ctl)
      next log&.("[#{ctl}, #{act}] skipped for #{sub}") unless can?(act, sub)

      role = ent[:role] || config_lookup('role', **ent.slice(:ctrlr, :action))
      next log&.("#{ent} needs #{role} role") unless user_has_role?(role, user)

      ent
    }.compact
  end

  # Generate controls specified by controller/action pairs generated by
  # #page_control_actions.
  #
  # Any control which would lead back to the current page is disabled and
  # marked to indicate that the selected action has already been chosen.
  #
  # @param [Array<Hash>]         entries    From #page_control_actions
  # @param [Symbol, String, nil] ctrlr      Current controller.
  # @param [Symbol, String, nil] action     Current action.
  # @param [Hash]                path_opt
  #
  # @return [ActiveSupport::SafeBuffer]
  #
  def page_controls(*entries, ctrlr: nil, action: nil, **path_opt)
    item_id  = path_opt.delete(:id)
    ctrlr    = ctrlr&.to_sym
    action   = action&.to_sym
    # noinspection RubyMismatchedArgumentType
    base     = action && base_action(action)
    special  = action && (action != base)
    action   = base if special && item_id
    link_opt = path_opt.delete(:link_opt)&.dup || {}
    link_opt.merge!(path_opt.extract!(:method))
    prepend_css!(link_opt, 'control', path_opt.delete(:class))

    entries.map { |entry|
      ctr  = entry[:ctrlr]
      act  = entry[:action]
      cfg  = config_page_section(ctr, act)
      role = entry.delete(:role)   || cfg[:role]
      next unless role.blank? || current_user&.has_role?(role)
      lbl  = entry.delete(:label)  || cfg[:label]
      prm  = entry.delete(:params) || cfg[:params] || {}
      opt  = path_opt.merge(entry, prm)
      opt[:link_opt] = opt[:link_opt]&.dup || cfg[:link_opt]&.dup || {}
      opt[:link_opt].merge!(link_opt)
      if act && action && (ctr == ctrlr)
        state = []
        state << 'current'  if base == base_action(act)
        state << 'disabled' if act  == action
        append_css!(opt[:link_opt], *state) if state.present?
      end
      link_to_action(lbl, **opt)
    }.compact.join("\n").html_safe
  end

  # page_controls_label
  #
  # @param [Hash] opt                 Passed to #config_lookup.
  #
  # @return [String]
  #
  def page_controls_label(**opt)
    opt = request_parameters.merge(opt)
    id  = opt.extract!(:id, :selected).compact.values.first
    unless %i[mode one many].intersect?(opt.keys)
      case Array.wrap(id).size
        when 0 then opt[:many] = true if menu_action?(opt[:action])
        when 1 then opt[:one]  = true
        else        opt[:many] = true
      end
    end
    config_lookup('page_controls.label', **opt) || config_term(:controls)
  end

  # ===========================================================================
  # :section:
  # ===========================================================================

  protected

  # Controllers which return *nil* for #model_class.
  #
  # @type [Array<Symbol>]
  #
  NO_MODEL_CONTROLLERS = %i[data health help metrics sys tool].freeze

  # Controllers which return *SearchResult* for #model_class.
  #
  # @type [Array<Symbol>]
  #
  SEARCH_MODEL_CONTROLLERS = %i[search].freeze

  # Controllers which return *User* for #model_class.
  #
  # @type [Array<Symbol>]
  #
  USER_MODEL_CONTROLLERS = %i[account home user].freeze

  # model_class
  #
  # @param [any, nil] ctrlr           Symbol, String, Class
  #
  # @return [Class]
  # @return [nil]
  #
  def model_class(ctrlr)
    ctrlr = ctrlr.to_sym if ctrlr.is_a?(String)
    case ctrlr
      when *NO_MODEL_CONTROLLERS                then return
      when *SEARCH_MODEL_CONTROLLERS            then return SearchResult
      when *USER_MODEL_CONTROLLERS, %r{^user/}  then return User
    end
    result = to_class(ctrlr)
    result = nil unless result&.ancestors&.include?(Model)
    result or Log.warn { "#{__method__}: unexpected: #{ctrlr.inspect}" }
  end

end

__loading_end(__FILE__)
