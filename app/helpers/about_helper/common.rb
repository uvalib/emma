# app/helpers/about_helper/common.rb
#
# frozen_string_literal: true
# warn_indent:           true

__loading_begin(__FILE__)

# View helper methods for rendering application information.
#
module AboutHelper::Common

  include CssHelper
  include HtmlHelper
  include EmmaHelper

  # ===========================================================================
  # :section:
  # ===========================================================================

  protected

  # The number of days for "recent".
  #
  # @type [Integer]
  #
  RECENT = config_page(:about, :recent)

  # ===========================================================================
  # :section:
  # ===========================================================================

  public

  # The past date indicated by the argument.
  #
  # @param [ActiveSupport::Duration, Date, Integer, nil] previous
  #
  # @return [Date, nil]
  #
  def recent_date(previous = RECENT.days)
    case previous
      when ActiveSupport::Duration then Date.today - previous.in_days
      when Integer                 then Date.today - previous.days
      when Date, nil               then previous
      else Log.error("#{__method__}: unexpected: #{previous.inspect}")
    end
  end

  # A faster way of grouping records containing a :user_id reference by
  # organization than the `has_one :org` association.
  #
  # @param [ActiveRecord::Relation] items
  #
  # @return [Hash{Org=>Array<ApplicationRecord>}]
  #
  def org_records(items)
    items.group_by { user_org[_1[:user_id]] }
  end

  # Generate a table mapping User ID to Org.
  #
  # @return [Hash{Integer=>Org,nil}]
  #
  def user_org
    @user_org ||=
      begin
        orgs = Org.all.map { |org| [org&.id, org] }.to_h
        User.all.pluck(:id, :org_id).map { |(user_id, org_id)|
          [user_id, orgs[org_id]]
        }.to_h
      end
  end

  # ===========================================================================
  # :section:
  # ===========================================================================

  protected

  # A fallback element indicating "NONE".
  #
  # @param [Hash] opt
  #
  # @return [ActiveSupport::SafeBuffer]
  #
  def none_placeholder(**opt)
    html_div(**opt) do
      config_term(:none).upcase
    end
  end

  # For use with #sort_by so that tables of total entries are sorted by name
  # and tables of recent entries are sorted by descending count with a
  # secondary sort by name.
  #
  # @param [*]                     key
  # @param [Hash{String=>Integer}] counts
  # @param [*]                     since
  #
  # @return [*]
  #
  def about_sort(key, counts, since: nil, **)
    if since
      [-counts.values.sum, about_sort(key, counts)]
    elsif key.is_a?(Org)
      key.long_name
    elsif EmmaRepository.valid?(key)
      EmmaRepository(key).label
    elsif key == Download::NO_PUBLISHER
      ''
    else
      key.to_s.downcase.gsub(/[[:punct:]]/, ' ').squish
    end
  end

  # Render the value for output as a table row header label.
  #
  # @param [*]      value
  # @param [Symbol] by
  #
  # @return [String]
  #
  def about_name(value, by:)
    case by
      when :source then EmmaRepository(value)&.label
      when :org    then value&.long_name
    end.presence || value.to_s
  end

  # Render a date value for a table row header label.
  #
  # @param [*] value
  #
  # @return [String, nil]
  #
  def about_date(value)
    date = value.presence
    date = date.created_at            if date.respond_to?(:created_at)
    date = date.strftime('%B %d, %Y') if date.respond_to?(:strftime)
    date
  end

  # A list of in-page links to the section groups on the page and to the
  # alternate representation of the page.
  #
  # @param [Array<String>] links
  # @param [Boolean]       fast
  #
  # @return [ActiveSupport::SafeBuffer]
  #
  def about_toc(links = nil, fast: false, **)
    if fast
      alt_url = make_path(request.path, complete: true)
      alt_lbl = 'Results with format counts (slow)' # TODO: I18n
    else
      alt_url = make_path(request.path, complete: false)
      alt_lbl = 'Results without format counts' # TODO: I18n
    end
    html_ul do
      links = yield if links.nil? && block_given?
      links = Array.wrap(links) << make_link(alt_url, alt_lbl)
      links.map do |link|
        html_li(link)
      end
    end
  end

  # A list of items as a table where data row headers are generated by the
  # block.
  #
  # @param [Hash]          items
  # @param [Array<String>] cols
  # @param [Boolean]       fast
  # @param [Hash]          opt        Passed to table element except:
  #
  # @option opt [String] :separator   Passed to #about_formats.
  #
  # @return [ActiveSupport::SafeBuffer]
  #
  # @yield [key] Generate a row header label.
  # @yieldparam [*] key
  # @yieldreturn [String]
  #
  def about_table(items, cols, fast: false, **opt)
    f_opt = opt.extract!(:separator).merge!(fast: fast)
    thead =
      html_thead do
        html_tr('aria-rowindex': 1) do
          cols = cols[0...-1] if fast
          cols.map.with_index(1) do |col, c|
            html_th(col, role: 'columnheader', 'aria-colindex': c)
          end
        end
      end
    tbody =
      html_tbody do
        items.map.with_index(2) do |(key, counts), r|
          name  = block_given? ? yield(key) : key
          total = counts.values.sum
          fmts  = about_formats(counts, **f_opt)
          html_tr('aria-rowindex': r) do
            name  = html_th(name,  role: 'rowheader', 'aria-colindex': 1)
            total = html_td(total, role: 'cell',      'aria-colindex': 2)
            fmts  = html_td(fmts,  role: 'cell',      'aria-colindex': 3) unless fast
            name << total << fmts
          end
        end
      end
    opt[:'aria-colcount'] = cols.size
    opt[:'aria-rowcount'] = items.size
    append_css!(opt, 'fast') if fast
    html_table(thead, tbody, **opt)
  end

  # A list of formats and their counts unless `counts` is of the form
  # `{ all: NNN }` indicating that this is the "fast" variant.
  #
  # @param [Hash]          counts
  # @param [Boolean]       fast
  # @param [String]        separator  Displayed between format counts.
  #
  # @return [String]
  #
  def about_formats(counts, fast: false, separator: " #{EM_DASH} ", **)
    return '' if fast || counts.key?(:all)
    counts.map { |f, c| "#{f}: #{c}" }.compact.join(separator)
  end

end

__loading_end(__FILE__)
