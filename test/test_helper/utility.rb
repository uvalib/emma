# test/test_helper/utility.rb
#
# frozen_string_literal: true
# warn_indent:           true

# General utility methods.
#
#--
# noinspection RubyTooManyMethodsInspection
#++
module TestHelper::Utility

  include TestHelper::Common
  include TestHelper::Debugging

  # Non-functional hints for RubyMine type checking.
  # :nocov:
  unless ONLY_FOR_DOCUMENTATION
    include Minitest::Assertions # for #refute
  end
  # :nocov:

  # ===========================================================================
  # :section:
  # ===========================================================================

  public

  # The subset of #TEST_FORMATS which do not include *allowed_formats*.
  #
  # @param [Array<Symbol>] allowed_formats
  #
  # @return [Array<Symbol>]
  #
  def formats_other_than(*allowed_formats)
    if allowed_formats.include?(:all)
      []
    else
      TEST_FORMATS.excluding(*allowed_formats)
    end
  end

  # Indicate whether *ctrlr* / *action* can be rendered with *fmt*.
  #
  # @param [Class]  ctrlr             A subclass of ApplicationController.
  # @param [Symbol] action
  # @param [Symbol] fmt
  #
  def supports_format?(ctrlr, action, fmt)
    if (format = ctrlr.mimes_for_respond_to[fmt]).nil?
      false
    elsif (only = format[:only])
      !only.blank? && only.include?(action)
    elsif (except = format[:except])
      except.blank? || !except.include?(action)
    end
  end

  # Run the test code provided via the block.
  #
  # When debugging, this frames the console output generated by the test.
  #
  # @param [String, Symbol, nil] name       Overrides `opt[:test]` if given.
  # @param [Symbol, nil]         format     @see #allowed_format.
  # @param [Array, Symbol, nil]  only       @see #allowed_format.
  # @param [Integer, nil]        wait       @see #using_wait_time.
  # @param [Hash]                opt        @see #SHOW_TEST_OPT
  # @param [Proc]                blk        Required block.
  #
  # @return [void]
  #
  # @yield The test code to be run
  # @yieldreturn [void]
  #
  def run_test(name = nil, format: nil, only: nil, wait: nil, **opt, &blk)
    error = nil
    prime_tests
    note  = (format.to_s.upcase unless format.nil? || html?(format))
    opt[:part] = [opt[:part], "[#{note}]"].compact.join(' - ') if note
    opt[:test] = name || opt[:test]
    show_test_start(**opt)
    if allowed_format(format, only: only)
      if wait
        using_wait_time(wait, &blk)
      else
        blk.call
      end
    end
  rescue Exception => error
    show_item("[#{error.class}: #{error}]")
  ensure
    show_test_end(**opt)
    raise error if error
  end

  # Local options for #run_test.
  #
  # @type [Array<Symbol>]
  #
  RUN_TEST_OPT = method_key_params(:run_test).concat(SHOW_TEST_OPT).freeze

  # ===========================================================================
  # :section:
  # ===========================================================================

  public

  # Make sure that "Sign in as" is visible on the sign-in page by ensuring that
  # the interface is in "debug mode".
  #
  # This also initializes `request.referrer` to a known good page so that
  # `redirect :back` will always work without need for a fallback location
  # (which may or may not be appropriate).
  #
  # @return [void]
  #
  def prime_tests
    meth = %i[visit get].find { respond_to?(_1) } or return
    without_tracing do
      # Since the option causes a redirect, it's a little faster to avoid it
      # for subsequent executions.
      opt = self.tests_primed ? {} : { debug: true }
      send(meth, root_url(**opt))
      self.tests_primed = true
    end
  end

  # @private
  # @type [Boolean, nil]
  attr_accessor :tests_primed
  protected :tests_primed

  # ===========================================================================
  # :section:
  # ===========================================================================

  public

  # For controller tests to covering the differences between authenticated and
  # non-authenticated sessions.
  #
  # @type [Array<Symbol>]
  #
  CORE_TEST_USERS = %i[anonymous test_dso_1].freeze

  # For controller tests to covering varying behaviors depending on the role
  # of the user session.
  #
  # @type [Array<Symbol>]
  #
  ALL_TEST_USERS =
    %i[anonymous test_guest_1 test_dso_1 test_man_1 test_adm].freeze

  # ===========================================================================
  # :section: Users
  # ===========================================================================

  public

  # The "/test/fixtures/users.yml" entry associated with the argument.
  #
  # @param [any, nil] arg             String, Symbol
  #
  # @return [Symbol, nil]
  #
  def user_entry(arg)
    arg = arg.sub(/@.*$/, '').presence&.to_sym if arg.is_a?(String)
    arg if arg.is_a?(Symbol) && (arg != :anonymous)
  end

  # Return a User instance from the given identification.
  #
  # @param [any, nil] user            String, Symbol, User
  #
  # @return [User]
  # @return [nil]                     If `*user*` could not be converted.
  #
  def find_user(user)
    user = user_entry(user) if user.is_a?(String)
    # noinspection RubyMismatchedArgumentType
    case user
      when :anonymous then nil
      when Symbol     then users(user)
      else                 User.instance_for(user)
    end
  end

  # Return multiple User instances.
  #
  # @param [Array] list               All users if empty.
  # @param [Hash]  matching           Limiting conditions if present.
  #
  # @return [Array<User,nil>]
  #
  def find_users(*list, **matching)
    anonymous = records = nil
    if list.present?
      list      = list.flatten
      original  = list.dup
      anonymous = list.reject! { _1.nil? || (_1 == :anonymous) }
      records   = list.reject! { _1.is_a?(User) }
      if list.present?
        list.map! { user_entry(_1) || _1 }
      elsif matching.blank?
        return original.map! { _1 if _1.is_a?(User) }
      end
    elsif matching.blank?
      return users
    end
    rec_ids = records&.map(&:id)
    added   = Array.wrap(users(*list))
    added   = added.reject { rec_ids.include?(_1.id) } if rec_ids.present?
    records = [*records, *added]
    if matching.present?
      matching = ApplicationRecord.normalize_id_keys(matching)
      records.keep_if do |u|
        matching.all? do |k, v|
          u_value = u.respond_to?(k) ? u.send(k) : u[k]
          if u_value.is_a?(Array) || v.is_a?(Array)
            Array.wrap(u_value).intersect?(Array.wrap(v))
          else
            u_value == v
          end
        end
      end
    end
    anonymous ? records.prepend(nil) : records
  end

  # ===========================================================================
  # :section: Organizations
  # ===========================================================================

  public

  # The "/test/fixtures/orgs.yml" entry associated with the argument.
  #
  # @param [any, nil] arg           String, Symbol, Org
  #
  # @return [Symbol, nil]
  #
  def org_entry(arg)
    arg = arg.presence&.to_sym if arg.is_a?(String)
    arg if arg.is_a?(Symbol) && (arg != :none)
  end

  # Return an Org instance from the given identification.
  #
  # @param [any, nil] org           String, Symbol, Org
  #
  # @return [Org]
  # @return [nil]                     If `*org*` could not be converted.
  #
  def find_org(org)
    org = org_entry(org) if org.is_a?(String)
    # noinspection RubyMismatchedArgumentType
    case org
      when :none  then nil
      when Symbol then orgs(org)
      else             Org.instance_for(org)
    end
  end

  # ===========================================================================
  # :section:
  # ===========================================================================

  public

  # Indicate whether `*user*` should be able to perform *action* on *subject*.
  #
  # @param [any, nil]       user      String, Symbol, User
  # @param [Symbol, String] action
  # @param [Class, nil]     subject   Def: MODEL constant defined by the class.
  # @param [any, nil]       extra
  #
  def can?(user, action, subject, *extra)
    subject ||= self_class.const_get(:MODEL)
    ability   = find_user(user)&.ability || Ability.new
    ability.can?(action, subject, *extra)
  end

  # Indicate whether `*user*` can perform *action* on *target*.
  #
  # If *user* is a manager then actions on *target* are allowed if it is
  # associated with the same organization as *user*.
  #
  # If *user* is an organization member read-only actions on *target* are
  # allowed if it is associated with the same organization as *user*; write
  # actions are allowed only if *target* is the same as *user* or otherwise
  # associated with the same user ID.
  #
  # @param [Symbol]     action
  # @param [User, nil]  user
  # @param [Model, nil] target
  # @param [Class, nil] model         Def: MODEL constant defined by the class.
  #
  def permitted?(action, user, target = nil, model: nil, **)
    model ||= self_class.const_get(:MODEL)
    return false unless can?(user, action, model)
    return true  if model == Upload
    return true  if target.nil?
    return false if user.nil?
    return true  if user.administrator?
    if user.manager? || %i[show index list_all list_org].include?(action)
      (user.oid == target.oid)
    else
      (user.uid == target.uid)
    end
  end

  # ===========================================================================
  # :section: Fixtures
  # ===========================================================================

  public

  # Extract the User ID indicated by *item*.
  #
  # @param [any, nil] item          Symbol, String, Integer, Hash, Model, User
  #
  # @return [Integer, nil]
  #
  def uid(item)
    # noinspection RubyMismatchedArgumentType
    case item
      when nil    then return
      when Symbol then item = users(item)
      when User   then # continue
      when Hash   then item = item[:user]     || item
      when Model  then item = item.try(:user) || item
    end
    case item
      when User   then item = item.id
      when Hash   then item = item[:user_id]
      when Model  then item = item[:user_id] || item.try(:user_id)
    end
    positive(item)
  end

  # Extract the Organization ID indicated by *item*.
  #
  # @param [any, nil] item          Symbol, String, Integer, Hash, Model, Org
  #
  # @return [Integer, nil]
  #
  def oid(item)
    # noinspection RubyMismatchedArgumentType
    case item
      when nil     then return
      when Symbol  then item = orgs(item)
      when Org     then # continue
      when Hash    then item = item[:org]     || item[:org_id] || item
      when Model   then item = item.try(:org) || item[:org_id] || item
    end
    case item
      when Integer then return non_negative(item)
      when Org     then return item.id
      when Hash    then item = item[:user]     || item
      when Model   then item = item.try(:user) || item
    end
    find_user(item)&.org_id
  end

  # ===========================================================================
  # :section: Fixtures
  # ===========================================================================

  public

  # The name of the fixture set for the indicated model type.
  #
  # @param [Symbol, String, Class, ApplicationRecord] model
  #
  # @return [String]
  #
  def fixture_name(model = nil)
    model_name(model).to_s.pluralize
  end

  # The number of fixture records for the indicated model and constraints which
  # are associated with an organization.
  #
  # @param [Symbol, String, Class, ApplicationRecord] model
  # @param [Org, User, Integer, nil]                  org
  # @param [Hash]                                     constraints
  #
  # @return [Integer]
  #
  def fixture_count_for_org(model, org, **constraints)
    fixture_values_for_org(model, org, **constraints).size
  end

  # The number of fixture records for the indicated model and constraints which
  # are associated with the given user.
  #
  # @param [Symbol, String, Class, ApplicationRecord] model
  # @param [User, Integer, nil]                       user
  # @param [Hash]                                     constraints
  #
  # @return [Integer]
  #
  def fixture_count_for_user(model, user, **constraints)
    fixture_values_for_user(model, user, **constraints).size
  end

  # The number of fixture records for the indicated model and constraints.
  #
  # @param [Symbol, String, Class, ApplicationRecord] model
  # @param [Hash]                                     constraints
  #
  # @return [Integer]
  #
  def fixture_count(model, **constraints)
    if constraints.present?
      fixture_values(model, **constraints).size
    else
      fixtures_of(model).size
    end
  end

  # A table of fixture value Hashes for the indicated model type, optionally
  # matching the given constraints, which are associated with an organization.
  #
  # @param [Symbol, String, Class, ApplicationRecord] model
  # @param [Org, User, Integer, nil]                  org
  # @param [Hash]                                     constraints
  #
  # @return [Hash{Symbol=>Hash}]
  #
  def fixture_values_for_org(model, org, **constraints)
    fixture_values(model, **constraints, org_id: org)
  end

  # A table of fixture value Hashes for the indicated model type, optionally
  # matching the given constraints, which are associated with the given user.
  #
  # @param [Symbol, String, Class, ApplicationRecord] model
  # @param [User, Integer, nil]                       user
  # @param [Hash]                                     constraints
  #
  # @return [Hash{Symbol=>Hash}]
  #
  def fixture_values_for_user(model, user, **constraints)
    fixture_values(model, **constraints, user_id: user)
  end

  # A table of fixture value Hashes for the indicated model type, optionally
  # matching the given constraints.
  #
  # @param [Symbol, String, Class, ApplicationRecord] model
  # @param [Hash]                                     constraints
  #
  # @return [Hash{Symbol=>Hash}]
  #
  def fixture_values(model, **constraints)
    # Prepare fixture value hashes.
    fixtures = fixtures_of(model)&.fixtures&.symbolize_keys
    fixtures&.transform_values! { _1.fixture.symbolize_keys }
    return fixtures || {} if fixtures.blank? || constraints.blank?

    # Prepare constraints for comparisons.
    constraints.each_pair do |k, v|
      if v.is_a?(ApplicationRecord)
        k = :"#{k}_id" unless (k == :id) || k.end_with?('_id')
      end
      case k
        when :user_id then v = uid(v) || v
        when :org_id  then v = oid(v) || v
        when :id      then v = v.id if v.is_a?(ApplicationRecord)
      end
      constraints[k] = Array.wrap(v)
    end

    # Constrain returned fixture values.
    fixtures.select do |_key, rec|
      constraints.all? do |k, constraint|
        case
          when rec.key?(k)  then v = rec[k]
          when k == :org_id then v = find_user(rec)&.oid
          else                   v = nil
        end
        constraint.blank? ? v.blank? : constraint.intersect?(Array.wrap(v))
      end
    end
  end

  # Fixture set for the indicated model type.
  #
  # @param [Symbol, String, Class, ApplicationRecord] model
  #
  # @return [ActiveRecord::FixtureSet, nil]
  #
  def fixtures_of(model)
    @loaded_fixtures[fixture_name(model)]
  end

  # ===========================================================================
  # :section: Models
  # ===========================================================================

  public

  # Get the number of records for the given *model* matching *constraints*.
  #
  # @param [any, nil] model         Symbol,String,Class,Model; def: self_class
  # @param [Hash]     constraints   Passed to #where.
  #
  # @return [Integer]
  #
  def get_model_count(model = nil, **constraints)
    model = model_class(model) or return 0
    if constraints.present?
      model.where(constraints).count
    else
      model.count
    end
  end

  # ===========================================================================
  # :section: Meta tests
  # ===========================================================================

  public

  # Controller methods which do not relate to controller endpoints, including
  # attributes defined directly within ApplicationController subclasses.
  #
  # @type [Array<Symbol>]
  #
  NON_PAGE_METHODS = %i[item list s3_object_table].freeze

  # Methods which are not applicable to system tests.
  #
  # @type [Array<Symbol>]
  #
  NON_SYSTEM_METHODS = %i[create update destroy].freeze

  # Fail if the current test class does not have controller tests covering all
  # of the endpoints of *ctrlr*.
  #
  # Controller tests are expected to be named like
  # * `test 'controller endpoint'` or
  # * `test 'controller endpoint - additional text'`.
  #
  # @param [Class]               ctrlr    Controller class
  # @param [Array<Symbol>, nil]  tests    Default: all tests in caller's class
  # @param [Array<Symbol>, nil]  except   Controller methods to skip.
  # @param [String, Symbol, nil] prefix   Instead of derived from *ctrlr*.
  #
  def check_controller_coverage(ctrlr, tests: nil, except: nil, prefix: nil)
    prefix &&= prefix.to_s.delete_suffix('_')
    prefix ||= ctrlr.name.underscore.delete_suffix('_controller')
    prefix   = "test_#{prefix}" unless prefix.start_with?('test_')
    tests  ||= self.class.public_instance_methods(false)
    tests    = tests.map { _1.to_s.sub(/^#{prefix}_(.*?)(_?-.*)?$/, '\1') }
    except   = [*except, *NON_PAGE_METHODS]
    pages    = methods_for(ctrlr).excluding(*except).map!(&:to_s)
    missing  = (pages - tests).presence&.sort
    refute missing, "Untested #{ctrlr.name} endpoints: #{missing}"
  end

  # Fail if the current test class does not have system tests covering all of
  # the endpoints of *ctrlr*.
  #
  # System tests are expected to be named like
  # * `test 'models - action'` or
  # * `test 'models - action - additional text'`.
  #
  # @param [Class]               ctrlr    Controller class
  # @param [Array<Symbol>, nil]  tests    Default: all tests in caller's class
  # @param [Array<Symbol>, nil]  except   Controller methods to skip.
  # @param [String, Symbol, nil] prefix   Instead of derived from *ctrlr*.
  #
  def check_system_coverage(ctrlr, tests: nil, except: nil, prefix: nil)
    prefix &&= prefix.to_s.delete_suffix('_')
    prefix ||= ctrlr.name.underscore.delete_suffix('_controller').pluralize
    prefix   = "test_#{prefix}" unless prefix.start_with?('test_')
    tests  ||= self.class.public_instance_methods(false)
    tests    = tests.map { _1.to_s.sub(/^#{prefix}_?-_?(.*?)(_?-.*)?$/, '\1') }
    except   = [*except, *NON_PAGE_METHODS, *NON_SYSTEM_METHODS]
    pages    = methods_for(ctrlr).excluding(*except).map!(&:to_s)
    missing  = (pages - tests).presence&.sort
    refute missing, "Untested #{ctrlr.name} actions: #{missing}"
  end

  # Fail if the current test class does not have mailer tests covering all of
  # the methods of *mailer*.
  #
  # Mailer tests are expected to be named like
  # * `test 'mailer model - method'` or
  # * `test 'mailer model - method - additional text'`.
  #
  # @param [Class]               mailer   Mailer class
  # @param [Array<Symbol>, nil]  tests    Default: all tests in caller's class
  # @param [Array<Symbol>, nil]  except   Controller methods to skip.
  # @param [String, Symbol, nil] prefix   Instead of derived from *ctrlr*.
  #
  def check_mailer_coverage(mailer, tests: nil, except: nil, prefix: nil)
    prefix &&= prefix.to_s.delete_suffix('_')
    prefix ||= mailer.name.underscore.delete_suffix('_mailer')
    prefix   = "test_mailer_#{prefix}"
    tests  ||= self.class.public_instance_methods(false)
    tests    = tests.map { _1.to_s.sub(/^#{prefix}_?-_?(.*?)(_?-.*)?$/, '\1') }
    except   = [*except, *NON_PAGE_METHODS, *NON_SYSTEM_METHODS]
    emails   = methods_for(mailer).excluding(*except).map!(&:to_s)
    missing  = (emails - tests).presence&.sort
    refute missing, "Untested #{mailer.name} actions: #{missing}"
  end

  # ===========================================================================
  # :section: Meta tests
  # ===========================================================================

  protected

  # Potential endpoint methods defined by the indicated controller.
  #
  # @param [Class, Symbol, String] ctrlr
  #
  # @return [Array<Symbol>]
  #
  def methods_for(ctrlr)
    ctrlr = "#{ctrlr}_controller".camelize  if ctrlr.is_a?(Symbol)
    ctrlr = ctrlr.safe_constantize          if ctrlr.is_a?(String)
    ctrlr.safe_const_get(:PAGES) || ctrlr.public_instance_methods(false)
  end

  # ===========================================================================
  # :section:
  # ===========================================================================

  public

  # Generate a string of random hex digits.
  #
  # @return [String]
  #
  def hex_rand
    CssHelper.hex_rand
  end

  # Extract the EMMA index entry identifier from the item.
  #
  # @param [SearchResult, nil] item
  # @param [String, nil]       repo
  # @param [String, nil]       rid
  # @param [String, nil]       format
  # @param [String, nil]       ver
  #
  # @return [String]
  #
  def record_id(item = nil, repo: nil, rid: nil, format: nil, ver: nil)
    if item.is_a?(SearchResult)
      repo   ||= item.repository
      rid    ||= item.repositoryRecordId
      format ||= item.format
      ver    ||= item.formatVersion
    end
    [repo, rid, format].compact_blank.tap { |parts|
      parts << ver if ver && (parts.size == 3)
    }.join('-')
  end

  # Note in the output that a test was skipped.
  #
  # @param [Array,nil] msg            Message part(s).
  # @param [Hash]      opt            Passed to #show_item.
  #
  # @return [void]
  #
  def show_skipped(*msg, **opt)
    line = ['TEST SKIPPED', *msg].compact.join(' - ')
    emit_lines(line, **opt)
  end

  # Note in the output that a test was skipped because it was not applicable.
  #
  # @param [String, nil] note         Additional annotation.
  # @param [Hash]        opt          Passed to #show_skipped.
  #
  # @return [true]
  #
  def not_applicable(note = nil, **opt)
    show_skipped(note, **opt)
    self.assertions += 1 # Suppress complaints about the test being skipped.
    true
  end

  # Note in the output that a test was skipped because the given format was not
  # applicable (or if none was given whether any of the currently configured
  # formats in #TEST_FORMATS are applicable).
  #
  # @param [Array, Symbol, nil] fmt
  # @param [String, nil]        note  Additional annotation.
  # @param [Array, Symbol, nil] only  Applicable format(s) or :all; default:
  #                                     #TEST_FORMATS.
  # @param [String]             tag
  # @param [Hash]               opt   Passed to #show_skipped.
  #
  # @return [true]                    If the test should proceed.
  # @return [false]                   If the test should be skipped.
  #
  def allowed_format(fmt = nil, note = nil, only:, tag: 'format', **opt)
    fmt, note = [nil, fmt] if fmt.is_a?(String)
    fmt  = Array.wrap(fmt).compact
    only = Array.wrap(only).compact
    only = TEST_FORMATS if only.blank? || only.include?(:all)

    return true if only.intersect?(fmt.presence || TEST_FORMATS)

    only = only.first    unless only.many?
    fmt  = fmt.first     unless fmt.many?
    tag  = tag.pluralize if only.is_a?(Array) || fmt.is_a?(Array)
    msg  =
      if fmt.nil?
        "ONLY APPLICABLE for #{only.inspect} #{tag}"
      elsif only.is_a?(Array)
        "NOT APPLICABLE - #{tag} #{fmt.inspect} not in #{only.inspect}"
      elsif fmt.is_a?(Array)
        "ONLY APPLICABLE for #{only.inspect} #{tag}"
      else
        "NOT APPLICABLE for #{fmt.inspect} #{tag}"
      end
    show_skipped(msg, note, **opt)
    false
  end

  # Generate a distinct email address based on the given options.
  #
  # @param [any, nil]    item
  # @param [String, nil] join
  # @param [Hash]        opt          Passed to #unique_name.
  #
  # @return [String]
  #
  def unique_email(item = nil, join: '_', **opt)
    local  = opt.slice!(:unique)
    item ||= local[:base]
    name   = (item         if item.is_a?(String))
    name ||= (item[:email] if item.is_a?(Hash) || item.is_a?(User))
    name ||= 'bogus@example.com'
    opt[:tag] = local.values_at(:action, :tag).push(name).compact.join(join)
    unique_name(join: join, **opt)
  end

  # Generate a distinct name based on the given options.
  #
  # @param [String, Array, nil] base
  # @param [Symbol, nil]        action
  # @param [String, nil]        unique
  # @param [String, nil]        tag
  # @param [String, nil]        join
  #
  # @return [String]
  #
  def unique_name(
    base:   nil,
    action: nil,
    unique: nil,
    tag:    nil,
    join:   ' - ',
    **
  )
    if base.nil?
      base = []
      name = action
    else
      base = base.is_a?(Array) ? base.flatten : [base]
      name = base.pop
      name = "#{name} (#{action})" if action
    end
    unique ||= hex_rand
    [*base, name, unique, tag].compact_blank.join(join)
  end

  UNIQUE_NAME_OPT = method_key_params(:unique_name).freeze

  # ===========================================================================
  # :section:
  # ===========================================================================

  public

  # For controllers whose "/index" action is actually a redirect to one or more
  # possible list actions.
  #
  # @param [Symbol, String, Proc, nil] dst
  # @param [any, nil]                  user   String, Symbol, User
  # @param [Hash]                      opt
  #
  # @return [String]                  The redirection path.
  #
  def index_redirect(dst: nil, user: nil, **opt)
    ctr = opt[:controller]
    dst = yield      if block_given?
    dst = dst.call   if dst.is_a?(Proc)
    dst = dst.to_sym if dst.is_a?(String)
    if dst.blank?
      user = find_user(user || current_user)
      case
        when user&.administrator? then dst = :list_all
        when user&.manager?       then dst = :list_org
        else                           dst = :list_own
      end
    end
    "/#{ctr}/#{dst}"
  end

  # ===========================================================================
  # :section:
  # ===========================================================================

  public

  # Cause the identified items to be updated in the EMMA Unified Index.
  #
  # @param [Array<Upload,String>] entries
  #
  # @return [Boolean]
  #
  def reindex(*entries)
    _, failures = UploadConcernShim.instance.reindex_submissions(*entries)
    failures.each { show_item(_1) }.blank?
  end

  # ===========================================================================
  # :section:
  # ===========================================================================

  private

  # This is an object that is used to access UploadConcern functionality that
  # is not dependent on the context of operating within an ActionController.
  #
  class UploadConcernShim

    include Singleton
    include UploadConcern

    # Required to satisfy #ingest_api.
    def session = @session ||= {}

    # Required to satisfy #api_service.
    def current_user = @current_user ||= User.new(role: :developer)

  end

  def self.included(base)
    __included(base, self)
    base.extend(self)
  end

end
