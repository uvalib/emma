# test/test_helper/debugging.rb
#
# frozen_string_literal: true
# warn_indent:           true

# Support for debugging tests.
#
module TestHelper::Debugging

  TEST_DEBUG_FRAME  = '-------'
  TEST_DEBUG_INDENT = '  '

  # ===========================================================================
  # :section:
  # ===========================================================================

  public

  RUN_TEST_OPT = %i[test part frame].freeze

  # Run the test code provided via the block.
  #
  # When debugging, this frames the console output generated by the test.
  #
  # @param [String, Symbol, nil] test_name
  # @param [String, nil]         test_part
  # @param [Hash]                opt        Passed to #show_test_start and
  #                                           #show_test_end.
  #
  # @return [void]
  #
  def run_test(test_name = nil, test_part = nil, **opt)
    e = nil
    show_test_start(test_name, test_part, **opt)
    yield # Run test code provided in the block.
  rescue Exception => e
    # Re-raise after 'ensure'.
  ensure
    show "[#{e.class}: #{e}]" if e
    show_test_end(test_name, test_part, **opt)
    raise e if e
  end

  # Produce the top frame of debug output for a test.
  #
  # @param [String, Symbol] test_name
  # @param [String, nil]    test_part
  # @param [Hash]           opt
  #
  # @option opt [String] :frame       Default: #TEST_DEBUG_FRAME.
  # @option opt [Symbol] :test        Default: *test_name*.
  # @option opt [String] :part        Default: *test_part*.
  #
  # @return [void]
  #
  def show_test_start(test_name, test_part = nil, **opt)
    line = opt[:frame] || TEST_DEBUG_FRAME
    name = opt[:test]  || test_name
    if name
      part = opt[:part] || test_part
      name = "#{name} - #{part} -" if part
      line = "#{line} #{name} START #{line}"
    end
    $stderr.puts "\n#{line}\n"
  end

  # Produce the bottom frame of debug output for a test.
  #
  # @param [String, Symbol] test_name
  # @param [String, nil]    test_part
  # @param [Hash]           opt
  #
  # @option opt [String] :frame       Default: #TEST_DEBUG_FRAME.
  # @option opt [Symbol] :test        Default: *test_name*.
  # @option opt [String] :part        Default: *test_part*.
  #
  # @return [void]
  #
  def show_test_end(test_name, test_part = nil, **opt)
    line = opt[:frame] || TEST_DEBUG_FRAME
    name = opt[:test]  || test_name
    if name
      part = opt[:part] || test_part
      name = "#{name} - #{part}" if part
      line = "#{line} END #{name} #{line}"
    end
    $stderr.puts "#{line}\n\n"
  end

  # ===========================================================================
  # :section:
  # ===========================================================================

  public

  SHOW_MODEL_OPT = %i[indent reflections].freeze

  # Display item model in output.
  #
  # @param [ActiveRecord::Base] item
  # @param [Hash]               opt     Passed to #show except for:
  #
  # @option opt [String]  :indent       Default: #TEST_DEBUG_INDENT
  # @option opt [Boolean] :reflections  Default: *true*
  #
  # @return [String]
  #
  def show_model(item, **opt)
    opt, show_opt = partition_options(opt, *SHOW_MODEL_OPT)
    details = opt[:reflections] || !opt.key?(:reflections)
    indent  = opt[:indent]|| TEST_DEBUG_INDENT
    not_indented = (indent == TEST_DEBUG_INDENT)
    show(**show_opt) do
      item.pretty_inspect.tap do |result|
        result.prepend("\n") if not_indented
        if details
          reflections = show_reflections(item, indent: indent, output: false)
          if reflections.present?
            result << "\n#{indent}REFLECTIONS\n\n"
            result << reflections.gsub(/^/, indent)
          end
        end
        result << "\n\n" if not_indented
      end
    end
  end

  # Display item model associations in output.
  #
  # @param [ActiveRecord::Base] item
  # @param [Hash]               opt   Passed to #show except for:
  #
  # @option opt [String] :indent      Default: #TEST_DEBUG_INDENT
  #
  # @return [String]
  #
  def show_reflections(item, **opt)
    opt, show_opt = partition_options(opt, :indent)
    indent = opt[:indent] || TEST_DEBUG_INDENT
    show(**show_opt) do
      item._reflections.map do |key, entry|
        items = Array.wrap(item.send(key)) rescue nil
        count = items ? items.size : 'ERROR'
        items &&= items.map { |i| i.pretty_inspect.gsub(/^/, indent) }.presence
        items &&= items.join("\n").prepend("\n\n")
        "#{key} (#{count}) [#{entry.class}]#{items}"
      end
    end
  end

  # Display item model associations in output.
  #
  # @param [URI, String, nil] url     Default: `#current_path`.
  # @param [Hash]             opt     Passed to #show.
  #
  # @yield
  # @yieldreturn [String]
  #
  # @return [String]
  #
  def show_url(url = nil, **opt)
    url ||= "URL = #{current_url}"
    show(url.to_s, **opt)
  end

  # Display item model associations in output.
  #
  # @param [User, String, nil] user   Default: `#current_user`.
  # @param [Hash]              opt    Passed to #show.
  #
  # @return [String]
  #
  def show_user(user = nil, **opt)
    user ||= current_user || 'anonymous'
    show(user.to_s, **opt)
  end

  # Display item contents in output.
  #
  # @param [Array] items
  # @param [Hash]  opt                Passed to #show_model except for:
  #
  # @option opt [String] :output      If *false* the result is not displayed.
  #
  # @return [String]                  The displayable result.
  #
  def show(*items, **opt)
    model_opt, opt = partition_options(opt, *SHOW_MODEL_OPT)
    model_opt[:output] = false
    items += Array.wrap(yield) if block_given?
    items.flatten.map { |item|
      case item
        when String             then item
        when ActiveRecord::Base then show_model(item, **model_opt)
        else                         item.pretty_inspect
      end
    }.join("\n\n").tap { |result|
      $stderr.puts result unless opt[:output] == false
    }
  end

  # ===========================================================================
  # :section:
  # ===========================================================================

  # Neutralize debugging methods when not debugging.
  unless defined?(TestHelper::DEBUG_TESTS) && TestHelper::DEBUG_TESTS
    instance_methods(false).each do |m|
      if m == :run_test
        module_eval "def #{m}(*); yield; end"
      else
        module_eval "def #{m}(*); end"
      end
    end
  end

end
